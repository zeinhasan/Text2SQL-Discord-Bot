import json
import mysql.connector
from mysql.connector import Error
from langchain_core.tools import tool
from typing import List, Dict, Any, Union
import pandas as pd

from config import llm
from utils import export_data_to_excel
from config import DB_HOST, DB_USER, DB_PASSWORD, DB_NAME
from datetime import datetime
import re

# --- HELPER FUNCTION TO SANITIZE SQL QUERY ---
def _sanitize_sql_query(raw_query: str) -> str:
    """
    Cleans the SQL query generated by the LLM by removing markdown code fences.
    """
    print(f"--- [TOOL_HELPER] Raw SQL from LLM: '{raw_query}' ---")
    if "```" in raw_query:
        parts = raw_query.split("```")
        if len(parts) > 1:
            query = parts[1]
            if query.lower().startswith(('mysql', 'sql')):
                query = query.split('\n', 1)[-1]
            sanitized_query = query.strip()
            print(f"[TOOL_HELPER] Sanitized SQL: '{sanitized_query}'")
            return sanitized_query
    return raw_query.strip()

# --- HELPER FUNCTIONS (No Changes) ---
def _get_db_connection() -> Union[mysql.connector.connection.MySQLConnection, dict]:
    """Helper function to create a database connection."""
    try:
        return mysql.connector.connect(
            host=DB_HOST, user=DB_USER, password=DB_PASSWORD, database=DB_NAME
        )
    except Error as e:
        print(f"--- [TOOLS_ERROR] Failed to connect to MySQL: {e} ---")
        return {"error": f"Failed to connect to the database: {e}"}

def _get_database_schema() -> str:
    """Internal helper to get the database schema for the LLM."""
    print("--- [TOOL_HELPER] Getting database schema... ---")
    conn = _get_db_connection()
    if isinstance(conn, dict): return conn["error"]
    
    cursor = conn.cursor()
    cursor.execute("SHOW TABLES;")
    tables = [table[0] for table in cursor.fetchall()]
    schema_info = "Here is the database schema:\n"
    for table_name in tables:
        schema_info += f"Table: {table_name}\nColumns:\n"
        cursor.execute(f"DESCRIBE `{table_name}`;")
        columns = cursor.fetchall()
        for col in columns:
            schema_info += f"  - {col[0]} ({col[1]})\n"
    cursor.close()
    conn.close()
    return schema_info

def _run_sql_query(query: str) -> List[Dict[str, Any]]:
    """Internal helper to run a SQL query."""
    print(f"--- [TOOL_HELPER] Running SQL query: '{query}' ---")
    conn = _get_db_connection()
    if isinstance(conn, dict): return [conn]
    
    try:
        df = pd.read_sql(query, conn)
        return df.to_dict('records')
    except Exception as e:
        print(f"--- [TOOLS_ERROR] SQL query failed: {e} ---")
        return [{"error": f"SQL Error: {e}"}]
    finally:
        if conn.is_connected():
            conn.close()

# --- HIGH-LEVEL TOOLS (Updated to use the sanitizer) ---

@tool
def get_database_info(question: str) -> str:
    """
    Use this tool to answer any user questions that require information from the database.
    This tool generates and executes SQL queries and returns a formatted text summary of the answer.
    It should not be used for requests that require file exports.
    """
    print(f"--- [TOOL_CALLED] query_database_and_get_text_result for question: '{question}' ---")
    schema = _get_database_schema()
    
    sql_generation_prompt = f"Schema:\n{schema}\n\nUser Question:\n{question}\n\nSQL Query:"
    raw_sql_query = llm.invoke(sql_generation_prompt).content
    
    # --- APPLY THE FIX HERE ---
    sql_query = _sanitize_sql_query(raw_sql_query)
    
    query_result = _run_sql_query(sql_query)
    
    if query_result and "error" in query_result[0]:
        return json.dumps(query_result)
        
    summary_prompt = f"The user asked: \"{question}\"\nThe result from the database is: {json.dumps(query_result, default=str)}\nPlease provide a concise, friendly, and well-formatted text answer."
    final_answer = llm.invoke(summary_prompt).content
    return final_answer

@tool
def export_database_info_to_excel(question: str) -> str:
    """
    Use this tool for any user question that requires data from the database and explicitly asks for it to be exported to a file, such as Excel or a spreadsheet.
    This tool generates and executes an SQL query, creates an Excel file with a dynamic name (e.g., 'tablename_timestamp.xlsx'), and returns the file path.
    """
    print(f"--- [TOOL_CALLED] query_database_and_export_to_excel for question: '{question}' ---")
    schema = _get_database_schema()

    # Step 1: Generate and sanitize SQL
    sql_generation_prompt = f"Schema:\n{schema}\n\nUser Question:\n{question}\n\nSQL Query:"
    raw_sql_query = llm.invoke(sql_generation_prompt).content
    sql_query = _sanitize_sql_query(raw_sql_query)
    
    # --- NEW: Step 2: Extract table name and create dynamic filename ---
    table_name = "export"  # Default name if table not found
    match = re.search(r'FROM\s+`?(\w+)`?', sql_query, re.IGNORECASE)
    if match:
        table_name = match.group(1)
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    dynamic_filename = f"{table_name}_{timestamp}.xlsx"
    print(f"--- [TOOL_HELPER] Generated dynamic filename: {dynamic_filename} ---")

    # Step 3: Execute the query
    query_result = _run_sql_query(sql_query)
    
    if not query_result or (isinstance(query_result, list) and query_result and "error" in query_result[0]):
        return f"Error executing query: {json.dumps(query_result)}"

    # Step 4: Export the result to Excel with the new dynamic filename
    file_path = export_data_to_excel(query_result, dynamic_filename)
    return file_path

@tool
def get_database_tables() -> str:
    """
    Use this tool when the user asks for the available tables in the database.
    It returns a formatted list of all table names.
    """
    print("--- [TOOL_CALLED] list_database_tables ---")
    conn = _get_db_connection()
    if isinstance(conn, dict):
        return f"Error connecting to database: {conn['error']}"

    try:
        cursor = conn.cursor()
        cursor.execute("SHOW TABLES;")
        tables = [table[0] for table in cursor.fetchall()]
        cursor.close()
        conn.close()
        
        if not tables:
            return "No tables were found in the database."
            
        return f"The following tables are available in the database: {', '.join(tables)}"
    except Exception as e:
        return f"An error occurred while trying to list tables: {e}"
    
all_tools = [
    get_database_info,
    export_database_info_to_excel,
    get_database_tables
]